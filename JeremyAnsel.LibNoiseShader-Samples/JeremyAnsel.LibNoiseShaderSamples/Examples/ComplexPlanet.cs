// This program demonstrates how to use the libnoise library to generate
// terrain elevations for a complex planetary surface that has the size of the
// earth.
//
// This program outputs a grid of elevation points in geographic (lat/lon)
// projection.  This program creates six files from this grid:
// - A Terragen terrain (*.ter) file that has its elevation points measured in
//   meters.  This file is generated only if the grid of elevation points has
//   a spatial resolution <= 240 meters.
// - A raw terrain (*.raw) file that has its elevation points measured in
//   meters.  This terrain file contains 16-bit signed big-endian values, in
//   row-major order, ordered south to north.
// - A Windows bitmap file (*.bmp) that is colored according to elevation and
//   lit by an artificial light source.
// - A Windows bitmap file (*.bmp) that is colored according to elevation
//   only.
// - A Windows bitmap file (*.bmp) containing the normals of the terrain.  The
//   red channel represents the x normal coordinate, the green channel
//   represents the y normal coordinate, and the blue channel represents the z
//   normal coordinate.  Initially, the normal coordinates are between -0.5
//   and +0.5, but when stored in the bitmap, this range is mapped from 0 to
//   255.
// - A Windows bitmap file (*.bmp) containing the specularity map of the
//   terrain.  Black indicates no specularity, while white indicates full
//   specularity.
//
// The grid of elevation points can have a maximum horizontal resolution of
// 0.25 arcseconds (~7.5 meters.)  A higher-resolution grid will cause the
// terrain to appear blurry.
//
// The terrain elevations are generated by a collection of over a hundred
// noise modules in a hierarchy of groups and subgroups.  Each group and
// subgroup outputs a single output value that originates from a caching
// module (noise::module::Cache).  Each group and subgroup can be thought of
// as a single complex noise module that can be used as a source module for
// other noise modules.  The caching module was chosen as the source of the
// output value to prevent costly recalculations by each group and subgroup
// requesting an output value from it.
//
// The following is a list of module groups and subgroups that build the
// planet's terrain:
//
// Group (continent definition)
//   Subgroup (base continent definition)
//   Subgroup (continent definition)
// Group (terrain type definition)
//   Subgroup (terrain type definition)
// Group (mountainous terrain)
//   Subgroup (mountain base definition)
//   Subgroup (high mountainous terrain)
//   Subgroup (low mountainous terrain)
//   Subgroup (mountainous terrain)
// Group (hilly terrain)
//   Subgroup (hilly terrain)
// Group (plains terrain)
//   Subgroup (plains terrain)
// Group (badlands terrain)
//   Subgroup (badlands sand)
//   Subgroup (badlands cliffs)
//   Subgroup (badlands terrain)
// Group (river positions)
//   Subgroup (river positions)
// Group (scaled mountainous terrain)
//   Subgroup (scaled mountainous terrain)
// Group (scaled hilly terrain)
//   Subgroup (scaled hilly terrain)
// Group (scaled plains terrain)
//   Subgroup (scaled plains terrain)
// Group (scaled badlands terrain)
//   Subgroup (scaled badlands terrain)
// Group (final planet)
//   Subgroup (continental shelf)
//   Subgroup (base continent elevation)
//   Subgroup (continents with plains)
//   Subgroup (continents with hills)
//   Subgroup (continents with mountains)
//   Subgroup (continents with badlands)
//   Subgroup (continents with rivers)
//   Subgroup (unscaled final planet)
//   Subgroup (final planet)
//
// A description of each group and subgroup can be found above the source code
// for that group and subgroup.

using JeremyAnsel.LibNoiseShader;
using JeremyAnsel.LibNoiseShader.Builders;
using JeremyAnsel.LibNoiseShader.IO.Models;
using JeremyAnsel.LibNoiseShader.Maps;
using JeremyAnsel.LibNoiseShader.Modules;
using JeremyAnsel.LibNoiseShader.Renderers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Drawing;

namespace JeremyAnsel.LibNoiseShaderSamples.Examples
{
    public static class ComplexPlanet
    {
        ////////////////////////////////////////////////////////////////////////////
        // Constants
        //
        // Modify these constants to change the terrain of the planet and to change
        // the boundaries and size of the elevation grid.
        //
        // Note: "Planetary elevation units" range from -1.0 (for the lowest
        // underwater trenches) to +1.0 (for the highest mountain peaks.)
        //

        // Southernmost coordinate of elevation grid.
        const float SOUTH_COORD = -90.0f;

        // Northernmost coordinate of elevation grid.
        const float NORTH_COORD = 90.0f;

        // Westernmost coordinate of elevation grid.
        const float WEST_COORD = -180.0f;

        // Easternmost coordinate of elevation grid.
        const float EAST_COORD = 180.0f;

        // Width of elevation grid, in points.
        //const int GRID_WIDTH = 4096;
        const int GRID_WIDTH = 512;

        // Height of elevation grid, in points.
        //const int GRID_HEIGHT = 2048;
        const int GRID_HEIGHT = 256;

        // Planet seed.  Change this to generate a different planet.
        const int CUR_SEED = 0;

        // Circumference of the planet, in meters.
        const float PLANET_CIRCUMFERENCE = 44236800.0f;

        // Minimum elevation on the planet, in meters.  This value is approximate.
        const float MIN_ELEV = -8192.0f;

        // Maximum elevation on the planet, in meters.  This value is approximate.
        const float MAX_ELEV = 8192.0f;

        // Frequency of the planet's continents.  Higher frequency produces smaller,
        // more numerous continents.  This value is measured in radians.
        const float CONTINENT_FREQUENCY = 1.0f;

        // Lacunarity of the planet's continents.  Changing this value produces
        // slightly different continents.  For the best results, this value should
        // be random, but close to 2.0.
        const float CONTINENT_LACUNARITY = 2.208984375f;

        // Lacunarity of the planet's mountains.  Changing this value produces
        // slightly different mountains.  For the best results, this value should
        // be random, but close to 2.0.
        const float MOUNTAIN_LACUNARITY = 2.142578125f;

        // Lacunarity of the planet's hills.  Changing this value produces slightly
        // different hills.  For the best results, this value should be random, but
        // close to 2.0.
        const float HILLS_LACUNARITY = 2.162109375f;

        // Lacunarity of the planet's plains.  Changing this value produces slightly
        // different plains.  For the best results, this value should be random, but
        // close to 2.0.
        const float PLAINS_LACUNARITY = 2.314453125f;

        // Lacunarity of the planet's badlands.  Changing this value produces
        // slightly different badlands.  For the best results, this value should be
        // random, but close to 2.0.
        const float BADLANDS_LACUNARITY = 2.212890625f;

        // Specifies the "twistiness" of the mountains.
        const float MOUNTAINS_TWIST = 1.0f;

        // Specifies the "twistiness" of the hills.
        const float HILLS_TWIST = 1.0f;

        // Specifies the "twistiness" of the badlands.
        const float BADLANDS_TWIST = 1.0f;

        // Specifies the planet's sea level.  This value must be between -1.0
        // (minimum planet elevation) and +1.0 (maximum planet elevation.)
        const float SEA_LEVEL = 0.0f;

        // Specifies the level on the planet in which continental shelves appear.
        // This value must be between -1.0 (minimum planet elevation) and +1.0
        // (maximum planet elevation), and must be less than SEA_LEVEL.
        const float SHELF_LEVEL = -0.375f;

        // Determines the amount of mountainous terrain that appears on the
        // planet.  Values range from 0.0 (no mountains) to 1.0 (all terrain is
        // covered in mountains).  Mountainous terrain will overlap hilly terrain.
        // Because the badlands terrain may overlap parts of the mountainous
        // terrain, setting MOUNTAINS_AMOUNT to 1.0 may not completely cover the
        // terrain in mountains.
        const float MOUNTAINS_AMOUNT = 0.5f;

        // Determines the amount of hilly terrain that appears on the planet.
        // Values range from 0.0 (no hills) to 1.0 (all terrain is covered in
        // hills).  This value must be less than MOUNTAINS_AMOUNT.  Because the
        // mountainous terrain will overlap parts of the hilly terrain, and
        // the badlands terrain may overlap parts of the hilly terrain, setting
        // HILLS_AMOUNT to 1.0 may not completely cover the terrain in hills.
        const float HILLS_AMOUNT = (1.0f + MOUNTAINS_AMOUNT) / 2.0f;

        // Determines the amount of badlands terrain that covers the planet.
        // Values range from 0.0 (no badlands) to 1.0 (all terrain is covered in
        // badlands.)  Badlands terrain will overlap any other type of terrain.
        const float BADLANDS_AMOUNT = 0.03125f;

        // Offset to apply to the terrain type definition.  Low values (< 1.0) cause
        // the rough areas to appear only at high elevations.  High values (> 2.0)
        // cause the rough areas to appear at any elevation.  The percentage of
        // rough areas on the planet are independent of this value.
        const float TERRAIN_OFFSET = 1.0f;

        // Specifies the amount of "glaciation" on the mountains.  This value
        // should be close to 1.0 and greater than 1.0.
        const float MOUNTAIN_GLACIATION = 1.375f;

        // Scaling to apply to the base continent elevations, in planetary elevation
        // units.
        const float CONTINENT_HEIGHT_SCALE = (1.0f - SEA_LEVEL) / 4.0f;

        // Maximum depth of the rivers, in planetary elevation units.
        const float RIVER_DEPTH = 0.0234375f;

        public static void Build(string outputDir)
        {
            Console.WriteLine("ComplexPlanet");

            var noise = new Noise3D(CUR_SEED);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: continent definition
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: base continent definition (7 noise modules)
            //
            // This subgroup roughly defines the positions and base elevations of the
            // planet's continents.
            //
            // The "base elevation" is the elevation of the terrain before any terrain
            // features (mountains, hills, etc.) are placed on that terrain.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Continent module]: This Perlin-noise module generates the continents.
            //    This noise module has a high number of octaves so that detail is
            //    visible at high zoom levels.
            PerlinModule baseContinentDef_pe0 = new(noise)
            {
                SeedOffset = CUR_SEED + 0,
                Frequency = CONTINENT_FREQUENCY,
                Persistence = 0.5f,
                Lacunarity = CONTINENT_LACUNARITY,
                OctaveCount = 14
            };

            // 2: [Continent-with-ranges module]: Next, a curve module modifies the
            //    output value from the continent module so that very high values appear
            //    near sea level.  This defines the positions of the mountain ranges.
            CurveModule baseContinentDef_cu = new(baseContinentDef_pe0);
            baseContinentDef_cu.ControlPoints.Clear();
            baseContinentDef_cu.ControlPoints.Add(-2.0000f + SEA_LEVEL, -1.625f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(-1.0000f + SEA_LEVEL, -1.375f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(0.0000f + SEA_LEVEL, -0.375f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(0.0625f + SEA_LEVEL, 0.125f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(0.1250f + SEA_LEVEL, 0.250f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(0.2500f + SEA_LEVEL, 1.000f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(0.5000f + SEA_LEVEL, 0.250f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(0.7500f + SEA_LEVEL, 0.250f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(1.0000f + SEA_LEVEL, 0.500f + SEA_LEVEL);
            baseContinentDef_cu.ControlPoints.Add(2.0000f + SEA_LEVEL, 0.500f + SEA_LEVEL);

            // 3: [Carver module]: This higher-frequency Perlin-noise module will be
            //    used by subsequent noise modules to carve out chunks from the mountain
            //    ranges within the continent-with-ranges module so that the mountain
            //    ranges will not be complely impassible.
            PerlinModule baseContinentDef_pe1 = new(noise)
            {
                SeedOffset = CUR_SEED + 1,
                Frequency = CONTINENT_FREQUENCY * 4.34375f,
                Persistence = 0.5f,
                Lacunarity = CONTINENT_LACUNARITY,
                OctaveCount = 11
            };

            // 4: [Scaled-carver module]: This scale/bias module scales the output
            //    value from the carver module such that it is usually near 1.0.  This
            //    is required for step 5.
            ScaleBiasModule baseContinentDef_sb = new(baseContinentDef_pe1)
            {
                Scale = 0.375f,
                Bias = 0.625f
            };

            // 5: [Carved-continent module]: This minimum-value module carves out chunks
            //    from the continent-with-ranges module.  It does this by ensuring that
            //    only the minimum of the output values from the scaled-carver module
            //    and the continent-with-ranges module contributes to the output value
            //    of this subgroup.  Most of the time, the minimum-value module will
            //    select the output value from the continents-with-ranges module since
            //    the output value from the scaled-carver module is usually near 1.0.
            //    Occasionally, the output value from the scaled-carver module will be
            //    less than the output value from the continent-with-ranges module, so
            //    in this case, the output value from the scaled-carver module is
            //    selected.
            MinModule baseContinentDef_mi = new(baseContinentDef_sb, baseContinentDef_cu);

            // 6: [Clamped-continent module]: Finally, a clamp module modifies the
            //    carved-continent module to ensure that the output value of this
            //    subgroup is between -1.0 and 1.0.
            ClampModule baseContinentDef_cl = new(baseContinentDef_mi);
            baseContinentDef_cl.SetBounds(-1.0f, 1.0f);

            // 7: [Base-continent-definition subgroup]: Caches the output value from the
            //    clamped-continent module.
            CacheModule baseContinentDef = new(baseContinentDef_cl);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continent definition (5 noise modules)
            //
            // This subgroup warps the output value from the the base-continent-
            // definition subgroup, producing more realistic terrain.
            //
            // Warping the base continent definition produces lumpier terrain with
            // cliffs and rifts.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the base-continent-definition subgroup, adding some coarse
            //    detail to it.
            TurbulenceModule continentDef_tu0 = new(noise, baseContinentDef)
            {
                SeedOffset = CUR_SEED + 10,
                Frequency = CONTINENT_FREQUENCY * 15.25f,
                Power = CONTINENT_FREQUENCY / 113.75f,
                Roughness = 13
            };

            // 2: [Intermediate-turbulence module]: This turbulence module warps the
            //    output value from the coarse-turbulence module.  This turbulence has
            //    a higher frequency, but lower power, than the coarse-turbulence
            //    module, adding some intermediate detail to it.
            TurbulenceModule continentDef_tu1 = new(noise, continentDef_tu0)
            {
                SeedOffset = CUR_SEED + 11,
                Frequency = CONTINENT_FREQUENCY * 47.25f,
                Power = CONTINENT_FREQUENCY / 433.75f,
                Roughness = 12
            };

            // 3: [Warped-base-continent-definition module]: This turbulence module
            //    warps the output value from the intermediate-turbulence module.  This
            //    turbulence has a higher frequency, but lower power, than the
            //    intermediate-turbulence module, adding some fine detail to it.
            TurbulenceModule continentDef_tu2 = new(noise, continentDef_tu1)
            {
                SeedOffset = CUR_SEED + 12,
                Frequency = CONTINENT_FREQUENCY * 95.25f,
                Power = CONTINENT_FREQUENCY / 1019.75f,
                Roughness = 11
            };

            // 4: [Select-turbulence module]: At this stage, the turbulence is applied
            //    to the entire base-continent-definition subgroup, producing some very
            //    rugged, unrealistic coastlines.  This selector module selects the
            //    output values from the (unwarped) base-continent-definition subgroup
            //    and the warped-base-continent-definition module, based on the output
            //    value from the (unwarped) base-continent-definition subgroup.  The
            //    selection boundary is near sea level and has a relatively smooth
            //    transition.  In effect, only the higher areas of the base-continent-
            //    definition subgroup become warped; the underwater and coastal areas
            //    remain unaffected.
            SelectorModule continentDef_se = new(baseContinentDef, continentDef_tu2, baseContinentDef);
            continentDef_se.SetBounds(SEA_LEVEL - 0.0375f, SEA_LEVEL + 1000.0375f);
            continentDef_se.EdgeFalloff = 0.0625f;

            // 7: [Continent-definition group]: Caches the output value from the
            //    clamped-continent module.  This is the output value for the entire
            //    continent-definition group.
            CacheModule continentDef = new(continentDef_se);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: terrain type definition
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: terrain type definition (3 noise modules)
            //
            // This subgroup defines the positions of the terrain types on the planet.
            //
            // Terrain types include, in order of increasing roughness, plains, hills,
            // and mountains.
            //
            // This subgroup's output value is based on the output value from the
            // continent-definition group.  Rougher terrain mainly appears at higher
            // elevations.
            //
            // -1.0 represents the smoothest terrain types (plains and underwater) and
            // +1.0 represents the roughest terrain types (mountains).
            //

            // 1: [Warped-continent module]: This turbulence module slightly warps the
            //    output value from the continent-definition group.  This prevents the
            //    rougher terrain from appearing exclusively at higher elevations.
            //    Rough areas may now appear in the the ocean, creating rocky islands
            //    and fjords.
            TurbulenceModule terrainTypeDef_tu = new(noise, continentDef)
            {
                SeedOffset = CUR_SEED + 20,
                Frequency = CONTINENT_FREQUENCY * 18.125f,
                Power = CONTINENT_FREQUENCY / 20.59375f * TERRAIN_OFFSET,
                Roughness = 3
            };

            // 2: [Roughness-probability-shift module]: This terracing module sharpens
            //    the edges of the warped-continent module near sea level and lowers
            //    the slope towards the higher-elevation areas.  This shrinks the areas
            //    in which the rough terrain appears, increasing the "rarity" of rough
            //    terrain.
            TerraceModule terrainTypeDef_te = new(terrainTypeDef_tu);
            terrainTypeDef_te.ControlPoints.Clear();
            terrainTypeDef_te.ControlPoints.Add(-1.00f);
            terrainTypeDef_te.ControlPoints.Add(SHELF_LEVEL + SEA_LEVEL / 2.0f);
            terrainTypeDef_te.ControlPoints.Add(1.00f);

            // 3: [Terrain-type-definition group]: Caches the output value from the
            //    roughness-probability-shift module.  This is the output value for
            //    the entire terrain-type-definition group.
            CacheModule terrainTypeDef = new(terrainTypeDef_te);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: mountainous terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: mountain base definition (9 noise modules)
            //
            // This subgroup generates the base-mountain elevations.  Other subgroups
            // will add the ridges and low areas to the base elevations.
            //
            // -1.0 represents low mountainous terrain and +1.0 represents high
            // mountainous terrain.
            //

            // 1: [Mountain-ridge module]: This ridged-multifractal-noise module
            //    generates the mountain ridges.
            RidgedMultiModule mountainBaseDef_rm0 = new(noise)
            {
                SeedOffset = CUR_SEED + 30,
                Frequency = 1723.0f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 4
            };

            // 2: [Scaled-mountain-ridge module]: Next, a scale/bias module scales the
            //    output value from the mountain-ridge module so that its ridges are not
            //    too high.  The reason for this is that another subgroup adds actual
            //    mountainous terrain to these ridges.
            ScaleBiasModule mountainBaseDef_sb0 = new(mountainBaseDef_rm0)
            {
                Scale = 0.5f,
                Bias = 0.375f
            };

            // 3: [River-valley module]: This ridged-multifractal-noise module generates
            //    the river valleys.  It has a much lower frequency than the mountain-
            //    ridge module so that more mountain ridges will appear outside of the
            //    valleys.  Note that this noise module generates ridged-multifractal
            //    noise using only one octave; this information will be important in the
            //    next step.
            RidgedMultiModule mountainBaseDef_rm1 = new(noise)
            {
                SeedOffset = CUR_SEED + 31,
                Frequency = 367.0f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 1
            };

            // 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
            //    scaling factor of -2.0 to the output value from the river-valley
            //    module.  This stretches the possible elevation values because one-
            //    octave ridged-multifractal noise has a lower range of output values
            //    than multiple-octave ridged-multifractal noise.  The negative scaling
            //    factor inverts the range of the output value, turning the ridges from
            //    the river-valley module into valleys.
            ScaleBiasModule mountainBaseDef_sb1 = new(mountainBaseDef_rm1)
            {
                Scale = -2.0f,
                Bias = -0.5f
            };

            // 5: [Low-flat module]: This low constant value is used by step 6.
            ConstantModule mountainBaseDef_co = new()
            {
                ConstantValue = -1.0f
            };

            // 6: [Mountains-and-valleys module]: This blender module merges the
            //    scaled-mountain-ridge module and the scaled-river-valley module
            //    together.  It causes the low-lying areas of the terrain to become
            //    smooth, and causes the high-lying areas of the terrain to contain
            //    ridges.  To do this, it uses the scaled-river-valley module as the
            //    control module, causing the low-flat module to appear in the lower
            //    areas and causing the scaled-mountain-ridge module to appear in the
            //    higher areas.
            BlendModule mountainBaseDef_bl = new(mountainBaseDef_co, mountainBaseDef_sb0, mountainBaseDef_sb1);

            // 7: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the mountain-and-valleys module, adding some coarse detail
            //    to it.
            TurbulenceModule mountainBaseDef_tu0 = new(noise, mountainBaseDef_bl)
            {
                SeedOffset = CUR_SEED + 32,
                Frequency = 1337.0f,
                Power = 1.0f / 6730.0f * MOUNTAINS_TWIST,
                Roughness = 4
            };

            // 8: [Warped-mountains-and-valleys module]: This turbulence module warps
            //    the output value from the coarse-turbulence module.  This turbulence
            //    has a higher frequency, but lower power, than the coarse-turbulence
            //    module, adding some fine detail to it.
            TurbulenceModule mountainBaseDef_tu1 = new(noise, mountainBaseDef_tu0)
            {
                SeedOffset = CUR_SEED + 33,
                Frequency = 21221.0f,
                Power = 1.0f / 120157.0f * MOUNTAINS_TWIST,
                Roughness = 6
            };

            // 9: [Mountain-base-definition subgroup]: Caches the output value from the
            //    warped-mountains-and-valleys module.
            CacheModule mountainBaseDef = new(mountainBaseDef_tu1);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: high mountainous terrain (5 noise modules)
            //
            // This subgroup generates the mountainous terrain that appears at high
            // elevations within the mountain ridges.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Mountain-basis-0 module]: This ridged-multifractal-noise module,
            //    along with the mountain-basis-1 module, generates the individual
            //    mountains.
            RidgedMultiModule mountainousHigh_rm0 = new(noise)
            {
                SeedOffset = CUR_SEED + 40,
                Frequency = 2371.0f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 3
            };

            // 2: [Mountain-basis-1 module]: This ridged-multifractal-noise module,
            //    along with the mountain-basis-0 module, generates the individual
            //    mountains.
            RidgedMultiModule mountainousHigh_rm1 = new(noise)
            {
                SeedOffset = CUR_SEED + 41,
                Frequency = 2341.0f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 3
            };

            // 3: [High-mountains module]: Next, a maximum-value module causes more
            //    mountains to appear at the expense of valleys.  It does this by
            //    ensuring that only the maximum of the output values from the two
            //    ridged-multifractal-noise modules contribute to the output value of
            //    this subgroup.
            MaxModule mountainousHigh_ma = new(mountainousHigh_rm0, mountainousHigh_rm1);

            // 4: [Warped-high-mountains module]: This turbulence module warps the
            //    output value from the high-mountains module, adding some detail to it.
            TurbulenceModule mountainousHigh_tu = new(noise, mountainousHigh_ma)
            {
                SeedOffset = CUR_SEED + 42,
                Frequency = 31511.0f,
                Power = 1.0f / 180371.0f * MOUNTAINS_TWIST,
                Roughness = 4
            };

            // 5: [High-mountainous-terrain subgroup]: Caches the output value from the
            //    warped-high-mountains module.
            CacheModule mountainousHigh = new(mountainousHigh_tu);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: low mountainous terrain (4 noise modules)
            //
            // This subgroup generates the mountainous terrain that appears at low
            // elevations within the river valleys.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Lowland-basis-0 module]: This ridged-multifractal-noise module,
            //    along with the lowland-basis-1 module, produces the low mountainous
            //    terrain.
            RidgedMultiModule mountainousLow_rm0 = new(noise)
            {
                SeedOffset = CUR_SEED + 50,
                Frequency = 1381.0f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 8
            };

            // 1: [Lowland-basis-1 module]: This ridged-multifractal-noise module,
            //    along with the lowland-basis-0 module, produces the low mountainous
            //    terrain.
            RidgedMultiModule mountainousLow_rm1 = new(noise)
            {
                SeedOffset = CUR_SEED + 51,
                Frequency = 1427.0f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 8
            };

            // 3: [Low-mountainous-terrain module]: This multiplication module combines
            //    the output values from the two ridged-multifractal-noise modules.
            //    This causes the following to appear in the resulting terrain:
            //    - Cracks appear when two negative output values are multiplied
            //      together.
            //    - Flat areas appear when a positive and a negative output value are
            //      multiplied together.
            //    - Ridges appear when two positive output values are multiplied
            //      together.
            MultiplyModule mountainousLow_mu = new(mountainousLow_rm0, mountainousLow_rm1);

            // 4: [Low-mountainous-terrain subgroup]: Caches the output value from the
            //    low-moutainous-terrain module.
            CacheModule mountainousLow = new(mountainousLow_mu);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: mountainous terrain (7 noise modules)
            //
            // This subgroup generates the final mountainous terrain by combining the
            // high-mountainous-terrain subgroup with the low-mountainous-terrain
            // subgroup.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Scaled-low-mountainous-terrain module]: First, this scale/bias module
            //    scales the output value from the low-mountainous-terrain subgroup to a
            //    very low value and biases it towards -1.0.  This results in the low
            //    mountainous areas becoming more-or-less flat with little variation.
            //    This will also result in the low mountainous areas appearing at the
            //    lowest elevations in this subgroup.
            ScaleBiasModule mountainousTerrain_sb0 = new(mountainousLow)
            {
                Scale = 0.03125f,
                Bias = -0.96875f
            };

            // 2: [Scaled-high-mountainous-terrain module]: Next, this scale/bias module
            //    scales the output value from the high-mountainous-terrain subgroup to
            //    1/4 of its initial value and biases it so that its output value is
            //    usually positive.
            ScaleBiasModule mountainousTerrain_sb1 = new(mountainousHigh)
            {
                Scale = 0.25f,
                Bias = 0.25f
            };

            // 3: [Added-high-mountainous-terrain module]: This addition module adds the
            //    output value from the scaled-high-mountainous-terrain module to the
            //    output value from the mountain-base-definition subgroup.  Mountains
            //    now appear all over the terrain.
            AddModule mountainousTerrain_ad = new(mountainousTerrain_sb1, mountainBaseDef);

            // 4: [Combined-mountainous-terrain module]: Note that at this point, the
            //    entire terrain is covered in high mountainous terrain, even at the low
            //    elevations.  To make sure the mountains only appear at the higher
            //    elevations, this selector module causes low mountainous terrain to
            //    appear at the low elevations (within the valleys) and the high
            //    mountainous terrain to appear at the high elevations (within the
            //    ridges.)  To do this, this noise module selects the output value from
            //    the added-high-mountainous-terrain module if the output value from the
            //    mountain-base-definition subgroup is higher than a set amount.
            //    Otherwise, this noise module selects the output value from the scaled-
            //    low-mountainous-terrain module.
            SelectorModule mountainousTerrain_se = new(mountainousTerrain_sb0, mountainousTerrain_ad, mountainBaseDef);
            mountainousTerrain_se.SetBounds(-0.5f, 999.5f);
            mountainousTerrain_se.EdgeFalloff = 0.5f;

            // 5: [Scaled-mountainous-terrain-module]: This scale/bias module slightly
            //    reduces the range of the output value from the combined-mountainous-
            //    terrain module, decreasing the heights of the mountain peaks.
            ScaleBiasModule mountainousTerrain_sb2 = new(mountainousTerrain_se)
            {
                Scale = 0.8f,
                Bias = 0.0f
            };

            // 6: [Glaciated-mountainous-terrain-module]: This exponential-curve module
            //    applies an exponential curve to the output value from the scaled-
            //    mountainous-terrain module.  This causes the slope of the mountains to
            //    smoothly increase towards higher elevations, as if a glacier grinded
            //    out those mountains.  This exponential-curve module expects the output
            //    value to range from -1.0 to +1.0.
            ExponentModule mountainousTerrain_ex = new(mountainousTerrain_sb2)
            {
                ExponentValue = MOUNTAIN_GLACIATION
            };

            // 7: [Mountainous-terrain group]: Caches the output value from the
            //    glaciated-mountainous-terrain module.  This is the output value for
            //    the entire mountainous-terrain group.
            CacheModule mountainousTerrain = new(mountainousTerrain_ex);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: hilly terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: hilly terrain (11 noise modules)
            //
            // This subgroup generates the hilly terrain.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Hills module]: This billow-noise module generates the hills.
            BillowModule hillyTerrain_bi = new(noise)
            {
                SeedOffset = CUR_SEED + 60,
                Frequency = 1663.0f,
                Persistence = 0.5f,
                Lacunarity = HILLS_LACUNARITY,
                OctaveCount = 6
            };

            // 2: [Scaled-hills module]: Next, a scale/bias module scales the output
            //    value from the hills module so that its hilltops are not too high.
            //    The reason for this is that these hills are eventually added to the
            //    river valleys (see below.)
            ScaleBiasModule hillyTerrain_sb0 = new(hillyTerrain_bi)
            {
                Scale = 0.5f,
                Bias = 0.5f
            };

            // 3: [River-valley module]: This ridged-multifractal-noise module generates
            //    the river valleys.  It has a much lower frequency so that more hills
            //    will appear in between the valleys.  Note that this noise module
            //    generates ridged-multifractal noise using only one octave; this
            //    information will be important in the next step.
            RidgedMultiModule hillyTerrain_rm = new(noise)
            {
                SeedOffset = CUR_SEED + 61,
                Frequency = 367.5f,
                Lacunarity = HILLS_LACUNARITY,
                OctaveCount = 1
            };

            // 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
            //    scaling factor of -2.0 to the output value from the river-valley
            //    module.  This stretches the possible elevation values because one-
            //    octave ridged-multifractal noise has a lower range of output values
            //    than multiple-octave ridged-multifractal noise.  The negative scaling
            //    factor inverts the range of the output value, turning the ridges from
            //    the river-valley module into valleys.
            ScaleBiasModule hillyTerrain_sb1 = new(hillyTerrain_rm)
            {
                Scale = -2.0f,
                Bias = -0.5f
            };

            // 5: [Low-flat module]: This low constant value is used by step 6.
            ConstantModule hillyTerrain_co = new(); ;
            hillyTerrain_co.ConstantValue = -1.0f;

            // 6: [Mountains-and-valleys module]: This blender module merges the
            //    scaled-hills module and the scaled-river-valley module together.  It
            //    causes the low-lying areas of the terrain to become smooth, and causes
            //    the high-lying areas of the terrain to contain hills.  To do this, it
            //    uses the scaled-hills module as the control module, causing the low-
            //    flat module to appear in the lower areas and causing the scaled-river-
            //    valley module to appear in the higher areas.
            BlendModule hillyTerrain_bl = new(hillyTerrain_co, hillyTerrain_sb1, hillyTerrain_sb0);

            // 7: [Scaled-hills-and-valleys module]: This scale/bias module slightly
            //    reduces the range of the output value from the hills-and-valleys
            //    module, decreasing the heights of the hilltops.
            ScaleBiasModule hillyTerrain_sb2 = new(hillyTerrain_bl)
            {
                Scale = 0.75f,
                Bias = -0.25f
            };

            // 8: [Increased-slope-hilly-terrain module]: To increase the hill slopes at
            //    higher elevations, this exponential-curve module applies an
            //    exponential curve to the output value the scaled-hills-and-valleys
            //    module.  This exponential-curve module expects the input value to
            //    range from -1.0 to 1.0.
            ExponentModule hillyTerrain_ex = new(hillyTerrain_sb2)
            {
                ExponentValue = 1.375f
            };

            // 9: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the increased-slope-hilly-terrain module, adding some
            //    coarse detail to it.
            TurbulenceModule hillyTerrain_tu0 = new(noise, hillyTerrain_ex)
            {
                SeedOffset = CUR_SEED + 62,
                Frequency = 1531.0f,
                Power = 1.0f / 16921.0f * HILLS_TWIST,
                Roughness = 4
            };

            // 10: [Warped-hilly-terrain module]: This turbulence module warps the
            //     output value from the coarse-turbulence module.  This turbulence has
            //     a higher frequency, but lower power, than the coarse-turbulence
            //     module, adding some fine detail to it.
            TurbulenceModule hillyTerrain_tu1 = new(noise, hillyTerrain_tu0)
            {
                SeedOffset = CUR_SEED + 63,
                Frequency = 21617.0f,
                Power = 1.0f / 117529.0f * HILLS_TWIST,
                Roughness = 6
            };

            // 11: [Hilly-terrain group]: Caches the output value from the warped-hilly-
            //     terrain module.  This is the output value for the entire hilly-
            //     terrain group.
            CacheModule hillyTerrain = new(hillyTerrain_tu1);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: plains terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: plains terrain (7 noise modules)
            //
            // This subgroup generates the plains terrain.
            //
            // Because this subgroup will eventually be flattened considerably, the
            // types and combinations of noise modules that generate the plains are not
            // really that important; they only need to "look" interesting.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Plains-basis-0 module]: This billow-noise module, along with the
            //    plains-basis-1 module, produces the plains.
            BillowModule plainsTerrain_bi0 = new(noise)
            {
                SeedOffset = CUR_SEED + 70,
                Frequency = 1097.5f,
                Persistence = 0.5f,
                Lacunarity = PLAINS_LACUNARITY,
                OctaveCount = 8
            };

            // 2: [Positive-plains-basis-0 module]: This scale/bias module makes the
            //    output value from the plains-basis-0 module positive since this output
            //    value will be multiplied together with the positive-plains-basis-1
            //    module.
            ScaleBiasModule plainsTerrain_sb0 = new(plainsTerrain_bi0)
            {
                Scale = 0.5f,
                Bias = 0.5f
            };

            // 3: [Plains-basis-1 module]: This billow-noise module, along with the
            //    plains-basis-2 module, produces the plains.
            BillowModule plainsTerrain_bi1 = new(noise)
            {
                SeedOffset = CUR_SEED + 71,
                Frequency = 1319.5f,
                Persistence = 0.5f,
                Lacunarity = PLAINS_LACUNARITY,
                OctaveCount = 8
            };

            // 4: [Positive-plains-basis-1 module]: This scale/bias module makes the
            //    output value from the plains-basis-1 module positive since this output
            //    value will be multiplied together with the positive-plains-basis-0
            //    module.
            ScaleBiasModule plainsTerrain_sb1 = new(plainsTerrain_bi1)
            {
                Scale = 0.5f,
                Bias = 0.5f
            };

            // 5: [Combined-plains-basis module]: This multiplication module combines
            //    the two plains basis modules together.
            MultiplyModule plainsTerrain_mu = new(plainsTerrain_sb0, plainsTerrain_sb1);

            // 6: [Rescaled-plains-basis module]: This scale/bias module maps the output
            //    value that ranges from 0.0 to 1.0 back to a value that ranges from
            //    -1.0 to +1.0.
            ScaleBiasModule plainsTerrain_sb2 = new(plainsTerrain_mu)
            {
                Scale = 2.0f,
                Bias = -1.0f
            };

            // 7: [Plains-terrain group]: Caches the output value from the rescaled-
            //    plains-basis module.  This is the output value for the entire plains-
            //    terrain group.
            CacheModule plainsTerrain = new(plainsTerrain_sb2);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: badlands terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: badlands sand (6 noise modules)
            //
            // This subgroup generates the sandy terrain for the badlands.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Sand-dunes module]: This ridged-multifractal-noise module generates
            //    sand dunes.  This ridged-multifractal noise is generated with a single
            //    octave, which makes very smooth dunes.
            RidgedMultiModule badlandsSand_rm = new(noise)
            {
                SeedOffset = CUR_SEED + 80,
                Frequency = 6163.5f,
                Lacunarity = BADLANDS_LACUNARITY,
                OctaveCount = 1
            };

            // 2: [Scaled-sand-dunes module]: This scale/bias module shrinks the dune
            //    heights by a small amount.  This is necessary so that the subsequent
            //    noise modules in this subgroup can add some detail to the dunes.
            ScaleBiasModule badlandsSand_sb0 = new(badlandsSand_rm)
            {
                Scale = 0.875f,
                Bias = 0.0f
            };

            // 3: [Dune-detail module]: This noise module uses Voronoi polygons to
            //    generate the detail to add to the dunes.  By enabling the distance
            //    algorithm, small polygonal pits are generated; the edges of the pits
            //    are joined to the edges of nearby pits.
            VoronoiModule badlandsSand_vo = new(noise)
            {
                SeedOffset = CUR_SEED + 81,
                Frequency = 16183.25f,
                IsDistanceApplied = true,
                Displacement = 0.0f
            };

            // 4: [Scaled-dune-detail module]: This scale/bias module shrinks the dune
            //    details by a large amount.  This is necessary so that the subsequent
            //    noise modules in this subgroup can add this detail to the sand-dunes
            //    module.
            ScaleBiasModule badlandsSand_sb1 = new(badlandsSand_vo)
            {
                Scale = 0.25f,
                Bias = 0.25f
            };

            // 5: [Dunes-with-detail module]: This addition module combines the scaled-
            //    sand-dunes module with the scaled-dune-detail module.
            AddModule badlandsSand_ad = new(badlandsSand_sb0, badlandsSand_sb1);

            // 6: [Badlands-sand subgroup]: Caches the output value from the dunes-with-
            //    detail module.
            CacheModule badlandsSand = new(badlandsSand_ad);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: badlands cliffs (7 noise modules)
            //
            // This subgroup generates the cliffs for the badlands.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Cliff-basis module]: This Perlin-noise module generates some coherent
            //    noise that will be used to generate the cliffs.
            PerlinModule badlandsCliffs_pe = new(noise)
            {
                SeedOffset = CUR_SEED + 90,
                Frequency = CONTINENT_FREQUENCY * 839.0f,
                Persistence = 0.5f,
                Lacunarity = BADLANDS_LACUNARITY,
                OctaveCount = 6
            };

            // 2: [Cliff-shaping module]: Next, this curve module applies a curve to the
            //    output value from the cliff-basis module.  This curve is initially
            //    very shallow, but then its slope increases sharply.  At the highest
            //    elevations, the curve becomes very flat again.  This produces the
            //    stereotypical Utah-style desert cliffs.
            CurveModule badlandsCliffs_cu = new(badlandsCliffs_pe);
            badlandsCliffs_cu.ControlPoints.Clear();
            badlandsCliffs_cu.ControlPoints.Add(-2.0000f, -2.0000f);
            badlandsCliffs_cu.ControlPoints.Add(-1.0000f, -1.2500f);
            badlandsCliffs_cu.ControlPoints.Add(-0.0000f, -0.7500f);
            badlandsCliffs_cu.ControlPoints.Add(0.5000f, -0.2500f);
            badlandsCliffs_cu.ControlPoints.Add(0.6250f, 0.8750f);
            badlandsCliffs_cu.ControlPoints.Add(0.7500f, 1.0000f);
            badlandsCliffs_cu.ControlPoints.Add(2.0000f, 1.2500f);

            // 3: [Clamped-cliffs module]: This clamping module makes the tops of the
            //    cliffs very flat by clamping the output value from the cliff-shaping
            //    module so that the tops of the cliffs are very flat.
            ClampModule badlandsCliffs_cl = new(badlandsCliffs_cu);
            badlandsCliffs_cl.SetBounds(-999.125f, 0.875f);

            // 4: [Terraced-cliffs module]: Next, this terracing module applies some
            //    terraces to the clamped-cliffs module in the lower elevations before
            //    the sharp cliff transition.
            TerraceModule badlandsCliffs_te = new(badlandsCliffs_cl);
            badlandsCliffs_te.ControlPoints.Clear();
            badlandsCliffs_te.ControlPoints.Add(-1.0000f);
            badlandsCliffs_te.ControlPoints.Add(-0.8750f);
            badlandsCliffs_te.ControlPoints.Add(-0.7500f);
            badlandsCliffs_te.ControlPoints.Add(-0.5000f);
            badlandsCliffs_te.ControlPoints.Add(0.0000f);
            badlandsCliffs_te.ControlPoints.Add(1.0000f);

            // 5: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the terraced-cliffs module, adding some coarse detail to
            //    it.
            TurbulenceModule badlandsCliffs_tu0 = new(noise, badlandsCliffs_te)
            {
                SeedOffset = CUR_SEED + 91,
                Frequency = 16111.0f,
                Power = 1.0f / 141539.0f * BADLANDS_TWIST,
                Roughness = 3
            };

            // 6: [Warped-cliffs module]: This turbulence module warps the output value
            //    from the coarse-turbulence module.  This turbulence has a higher
            //    frequency, but lower power, than the coarse-turbulence module, adding
            //    some fine detail to it.
            TurbulenceModule badlandsCliffs_tu1 = new(noise, badlandsCliffs_tu0)
            {
                SeedOffset = CUR_SEED + 92,
                Frequency = 36107.0f,
                Power = 1.0f / 211543.0f * BADLANDS_TWIST,
                Roughness = 3
            };

            // 7: [Badlands-cliffs subgroup]: Caches the output value from the warped-
            //    cliffs module.
            CacheModule badlandsCliffs = new(badlandsCliffs_tu1);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: badlands terrain (3 noise modules)
            //
            // Generates the final badlands terrain.
            //
            // Using a scale/bias module, the badlands sand is flattened considerably,
            // then the sand elevations are lowered to around -1.0.  The maximum value
            // from the flattened sand module and the cliff module contributes to the
            // final elevation.  This causes sand to appear at the low elevations since
            // the sand is slightly higher than the cliff base.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Scaled-sand-dunes module]: This scale/bias module considerably
            //    flattens the output value from the badlands-sands subgroup and lowers
            //    this value to near -1.0.
            ScaleBiasModule badlandsTerrain_sb = new(badlandsSand)
            {
                Scale = 0.25f,
                Bias = -0.75f
            };

            // 2: [Dunes-and-cliffs module]: This maximum-value module causes the dunes
            //    to appear in the low areas and the cliffs to appear in the high areas.
            //    It does this by selecting the maximum of the output values from the
            //    scaled-sand-dunes module and the badlands-cliffs subgroup.
            MaxModule badlandsTerrain_ma = new(badlandsCliffs, badlandsTerrain_sb);

            // 3: [Badlands-terrain group]: Caches the output value from the dunes-and-
            //    cliffs module.  This is the output value for the entire badlands-
            //    terrain group.
            CacheModule badlandsTerrain = new(badlandsTerrain_ma);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: river positions
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: river positions (7 noise modules)
            //
            // This subgroup generates the river positions.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Large-river-basis module]: This ridged-multifractal-noise module
            //    creates the large, deep rivers.
            RidgedMultiModule riverPositions_rm0 = new(noise)
            {
                SeedOffset = CUR_SEED + 100,
                Frequency = 18.75f,
                Lacunarity = CONTINENT_LACUNARITY,
                OctaveCount = 1
            };

            // 2: [Large-river-curve module]: This curve module applies a curve to the
            //    output value from the large-river-basis module so that the ridges
            //    become inverted.  This creates the rivers.  This curve also compresses
            //    the edge of the rivers, producing a sharp transition from the land to
            //    the river bottom.
            CurveModule riverPositions_cu0 = new(riverPositions_rm0);
            riverPositions_cu0.ControlPoints.Clear();
            riverPositions_cu0.ControlPoints.Add(-2.000f, 2.000f);
            riverPositions_cu0.ControlPoints.Add(-1.000f, 1.000f);
            riverPositions_cu0.ControlPoints.Add(-0.125f, 0.875f);
            riverPositions_cu0.ControlPoints.Add(0.000f, -1.000f);
            riverPositions_cu0.ControlPoints.Add(1.000f, -1.500f);
            riverPositions_cu0.ControlPoints.Add(2.000f, -2.000f);

            /// 3: [Small-river-basis module]: This ridged-multifractal-noise module
            //     creates the small, shallow rivers.
            RidgedMultiModule riverPositions_rm1 = new(noise)
            {
                SeedOffset = CUR_SEED + 101,
                Frequency = 43.25f,
                Lacunarity = CONTINENT_LACUNARITY,
                OctaveCount = 1
            };

            // 4: [Small-river-curve module]: This curve module applies a curve to the
            //    output value from the small-river-basis module so that the ridges
            //    become inverted.  This creates the rivers.  This curve also compresses
            //    the edge of the rivers, producing a sharp transition from the land to
            //    the river bottom.
            CurveModule riverPositions_cu1 = new(riverPositions_rm1);
            riverPositions_cu1.ControlPoints.Clear();
            riverPositions_cu1.ControlPoints.Add(-2.000f, 2.0000f);
            riverPositions_cu1.ControlPoints.Add(-1.000f, 1.5000f);
            riverPositions_cu1.ControlPoints.Add(-0.125f, 1.4375f);
            riverPositions_cu1.ControlPoints.Add(0.000f, 0.5000f);
            riverPositions_cu1.ControlPoints.Add(1.000f, 0.2500f);
            riverPositions_cu1.ControlPoints.Add(2.000f, 0.0000f);

            // 5: [Combined-rivers module]: This minimum-value module causes the small
            //    rivers to cut into the large rivers.  It does this by selecting the
            //    minimum output values from the large-river-curve module and the small-
            //    river-curve module.
            MinModule riverPositions_mi = new(riverPositions_cu0, riverPositions_cu1);

            // 6: [Warped-rivers module]: This turbulence module warps the output value
            //    from the combined-rivers module, which twists the rivers.  The high
            //    roughness produces less-smooth rivers.
            TurbulenceModule riverPositions_tu = new(noise, riverPositions_mi)
            {
                SeedOffset = CUR_SEED + 102,
                Frequency = 9.25f,
                Power = 1.0f / 57.75f,
                Roughness = 6
            };

            // 7: [River-positions group]: Caches the output value from the warped-
            //    rivers module.  This is the output value for the entire river-
            //    positions group.
            CacheModule riverPositions = new(riverPositions_tu);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled mountainous terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled mountainous terrain (6 noise modules)
            //
            // This subgroup scales the output value from the mountainous-terrain group
            // so that it can be added to the elevation defined by the continent-
            // definition group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that a negative elevation does not get applied
            // to the continent-definition group, preventing parts of that group from
            // having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Base-scaled-mountainous-terrain module]: This scale/bias module
            //    scales the output value from the mountainous-terrain group so that the
            //    output value is measured in planetary elevation units.
            ScaleBiasModule scaledMountainousTerrain_sb0 = new(mountainousTerrain)
            {
                Scale = 0.125f,
                Bias = 0.125f
            };

            // 2: [Base-peak-modulation module]: At this stage, most mountain peaks have
            //    roughly the same elevation.  This Perlin-noise module generates some
            //    random values that will be used by subsequent noise modules to
            //    randomly change the elevations of the mountain peaks.
            PerlinModule scaledMountainousTerrain_pe = new(noise)
            {
                SeedOffset = CUR_SEED + 110,
                Frequency = 14.5f,
                Persistence = 0.5f,
                Lacunarity = MOUNTAIN_LACUNARITY,
                OctaveCount = 6
            };

            // 3: [Peak-modulation module]: This exponential-curve module applies an
            //    exponential curve to the output value from the base-peak-modulation
            //    module.  This produces a small number of high values and a much larger
            //    number of low values.  This means there will be a few peaks with much
            //    higher elevations than the majority of the peaks, making the terrain
            //    features more varied.
            ExponentModule scaledMountainousTerrain_ex = new(scaledMountainousTerrain_pe)
            {
                ExponentValue = 1.25f
            };

            // 4: [Scaled-peak-modulation module]: This scale/bias module modifies the
            //    range of the output value from the peak-modulation module so that it
            //    can be used as the modulator for the peak-height-multiplier module.
            //    It is important that this output value is not much lower than 1.0.
            ScaleBiasModule scaledMountainousTerrain_sb1 = new(scaledMountainousTerrain_ex)
            {
                Scale = 0.25f,
                Bias = 1.0f
            };

            // 5: [Peak-height-multiplier module]: This multiplier module modulates the
            //    heights of the mountain peaks from the base-scaled-mountainous-terrain
            //    module using the output value from the scaled-peak-modulation module.
            MultiplyModule scaledMountainousTerrain_mu = new(scaledMountainousTerrain_sb0, scaledMountainousTerrain_sb1);

            // 6: [Scaled-mountainous-terrain group]: Caches the output value from the
            //    peak-height-multiplier module.  This is the output value for the
            //    entire scaled-mountainous-terrain group.
            CacheModule scaledMountainousTerrain = new(scaledMountainousTerrain_mu);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled hilly terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled hilly terrain (6 noise modules)
            //
            // This subgroup scales the output value from the hilly-terrain group so
            // that it can be added to the elevation defined by the continent-
            // definition group.  The scaling amount applied to the hills is one half of
            // the scaling amount applied to the scaled-mountainous-terrain group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that negative elevations are not applied to
            // the continent-definition group, preventing parts of the continent-
            // definition group from having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Base-scaled-hilly-terrain module]: This scale/bias module scales the
            //    output value from the hilly-terrain group so that this output value is
            //    measured in planetary elevation units 
            ScaleBiasModule scaledHillyTerrain_sb0 = new(hillyTerrain)
            {
                Scale = 0.0625f,
                Bias = 0.0625f
            };

            // 2: [Base-hilltop-modulation module]: At this stage, most hilltops have
            //    roughly the same elevation.  This Perlin-noise module generates some
            //    random values that will be used by subsequent noise modules to
            //    randomly change the elevations of the hilltops.
            PerlinModule scaledHillyTerrain_pe = new(noise)
            {
                SeedOffset = CUR_SEED + 120,
                Frequency = 13.5f,
                Persistence = 0.5f,
                Lacunarity = HILLS_LACUNARITY,
                OctaveCount = 6
            };

            // 3: [Hilltop-modulation module]: This exponential-curve module applies an
            //    exponential curve to the output value from the base-hilltop-modulation
            //    module.  This produces a small number of high values and a much larger
            //    number of low values.  This means there will be a few hilltops with
            //    much higher elevations than the majority of the hilltops, making the
            //    terrain features more varied.
            ExponentModule scaledHillyTerrain_ex = new(scaledHillyTerrain_pe)
            {
                ExponentValue = 1.25f
            };

            // 4: [Scaled-hilltop-modulation module]: This scale/bias module modifies
            //    the range of the output value from the hilltop-modulation module so
            //    that it can be used as the modulator for the hilltop-height-multiplier
            //    module.  It is important that this output value is not much lower than
            //    1.0.
            ScaleBiasModule scaledHillyTerrain_sb1 = new(scaledHillyTerrain_ex)
            {
                Scale = 0.5f,
                Bias = 1.5f
            };

            // 5: [Hilltop-height-multiplier module]: This multiplier module modulates
            //    the heights of the hilltops from the base-scaled-hilly-terrain module
            //    using the output value from the scaled-hilltop-modulation module.
            MultiplyModule scaledHillyTerrain_mu = new(scaledHillyTerrain_sb0, scaledHillyTerrain_sb1);

            // 6: [Scaled-hilly-terrain group]: Caches the output value from the
            //    hilltop-height-multiplier module.  This is the output value for the
            //    entire scaled-hilly-terrain group.
            CacheModule scaledHillyTerrain = new(scaledHillyTerrain_mu);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled plains terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled plains terrain (2 noise modules)
            //
            // This subgroup scales the output value from the plains-terrain group so
            // that it can be added to the elevations defined by the continent-
            // definition group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that negative elevations are not applied to
            // the continent-definition group, preventing parts of the continent-
            // definition group from having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Scaled-plains-terrain module]: This scale/bias module greatly
            //    flattens the output value from the plains terrain.  This output value
            //    is measured in planetary elevation units 
            ScaleBiasModule scaledPlainsTerrain_sb = new(plainsTerrain)
            {
                Scale = 0.00390625f,
                Bias = 0.0078125f
            };

            // 2: [Scaled-plains-terrain group]: Caches the output value from the
            //    scaled-plains-terrain module.  This is the output value for the entire
            //    scaled-plains-terrain group.
            CacheModule scaledPlainsTerrain = new(scaledPlainsTerrain_sb);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled badlands terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled badlands terrain (2 noise modules)
            //
            // This subgroup scales the output value from the badlands-terrain group so
            // that it can be added to the elevations defined by the continent-
            // definition group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that negative elevations are not applied to
            // the continent-definition group, preventing parts of the continent-
            // definition group from having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Scaled-badlands-terrain module]: This scale/bias module scales the
            //    output value from the badlands-terrain group so that it is measured
            //    in planetary elevation units 
            ScaleBiasModule scaledBadlandsTerrain_sb = new(badlandsTerrain)
            {
                Scale = 0.0625f,
                Bias = 0.0625f
            };

            // 2: [Scaled-badlands-terrain group]: Caches the output value from the
            //    scaled-badlands-terrain module.  This is the output value for the
            //    entire scaled-badlands-terrain group.
            CacheModule scaledBadlandsTerrain = new(scaledBadlandsTerrain_sb);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: final planet
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continental shelf (6 noise modules)
            //
            // This module subgroup creates the continental shelves.
            //
            // The output value from this module subgroup are measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Shelf-creator module]: This terracing module applies a terracing
            //    curve to the continent-definition group at the specified shelf level.
            //    This terrace becomes the continental shelf.  Note that this terracing
            //    module also places another terrace below the continental shelf near
            //    -1.0.  The bottom of this terrace is defined as the bottom of the
            //    ocean; subsequent noise modules will later add oceanic trenches to the
            //    bottom of the ocean.
            TerraceModule continentalShelf_te = new(continentDef);
            continentalShelf_te.ControlPoints.Clear();
            continentalShelf_te.ControlPoints.Add(-1.0f);
            continentalShelf_te.ControlPoints.Add(-0.75f);
            continentalShelf_te.ControlPoints.Add(SHELF_LEVEL);
            continentalShelf_te.ControlPoints.Add(1.0f);

            // 2: [Oceanic-trench-basis module]: This ridged-multifractal-noise module
            //    generates some coherent noise that will be used to generate the
            //    oceanic trenches.  The ridges represent the bottom of the trenches.
            RidgedMultiModule continentalShelf_rm = new(noise)
            {
                SeedOffset = CUR_SEED + 130,
                Frequency = CONTINENT_FREQUENCY * 4.375f,
                Lacunarity = CONTINENT_LACUNARITY,
                OctaveCount = 16
            };

            // 3: [Oceanic-trench module]: This scale/bias module inverts the ridges
            //    from the oceanic-trench-basis-module so that the ridges become
            //    trenches.  This noise module also reduces the depth of the trenches so
            //    that their depths are measured in planetary elevation units.
            ScaleBiasModule continentalShelf_sb = new(continentalShelf_rm)
            {
                Scale = -0.125f,
                Bias = -0.125f
            };

            // 4: [Clamped-sea-bottom module]: This clamping module clamps the output
            //    value from the shelf-creator module so that its possible range is
            //    from the bottom of the ocean to sea level.  This is done because this
            //    subgroup is only concerned about the oceans.
            ClampModule continentalShelf_cl = new(continentalShelf_te);
            continentalShelf_cl.SetBounds(-0.75f, SEA_LEVEL);

            // 5: [Shelf-and-trenches module]: This addition module adds the oceanic
            //    trenches to the clamped-sea-bottom module.
            AddModule continentalShelf_ad = new(continentalShelf_sb, continentalShelf_cl);

            // 6: [Continental-shelf subgroup]: Caches the output value from the shelf-
            //    and-trenches module.
            CacheModule continentalShelf = new(continentalShelf_ad);

            ////////////////////////////////////////////////////////////////////////////
            // Module group: base continent elevations (3 noise modules)
            //
            // This subgroup generates the base elevations for the continents, before
            // terrain features are added.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Base-scaled-continent-elevations module]: This scale/bias module
            //    scales the output value from the continent-definition group so that it
            //    is measured in planetary elevation units 
            ScaleBiasModule baseContinentElev_sb = new(continentDef)
            {
                Scale = CONTINENT_HEIGHT_SCALE,
                Bias = 0.0f
            };

            // 2: [Base-continent-with-oceans module]: This selector module applies the
            //    elevations of the continental shelves to the base elevations of the
            //    continent.  It does this by selecting the output value from the
            //    continental-shelf subgroup if the corresponding output value from the
            //    continent-definition group is below the shelf level.  Otherwise, it
            //    selects the output value from the base-scaled-continent-elevations
            //    module.
            SelectorModule baseContinentElev_se = new(baseContinentElev_sb, continentalShelf, continentDef);
            baseContinentElev_se.SetBounds(SHELF_LEVEL - 1000.0f, SHELF_LEVEL);
            baseContinentElev_se.EdgeFalloff = 0.03125f;

            // 3: [Base-continent-elevation subgroup]: Caches the output value from the
            //    base-continent-with-oceans module.
            CacheModule baseContinentElev = new(baseContinentElev_se);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with plains (2 noise modules)
            //
            // This subgroup applies the scaled-plains-terrain group to the base-
            // continent-elevation subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Continents-with-plains module]:  This addition module adds the
            //    scaled-plains-terrain group to the base-continent-elevation subgroup.
            AddModule continentsWithPlains_ad = new(baseContinentElev, scaledPlainsTerrain);

            // 2: [Continents-with-plains subgroup]: Caches the output value from the
            //    continents-with-plains module.
            CacheModule continentsWithPlains = new(continentsWithPlains_ad);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with hills (3 noise modules)
            //
            // This subgroup applies the scaled-hilly-terrain group to the continents-
            // with-plains subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Continents-with-hills module]:  This addition module adds the scaled-
            //    hilly-terrain group to the base-continent-elevation subgroup.
            AddModule continentsWithHills_ad = new(baseContinentElev, scaledHillyTerrain);

            // 2: [Select-high-elevations module]: This selector module ensures that
            //    the hills only appear at higher elevations.  It does this by selecting
            //    the output value from the continent-with-hills module if the
            //    corresponding output value from the terrain-type-defintion group is
            //    above a certain value. Otherwise, it selects the output value from the
            //    continents-with-plains subgroup.
            SelectorModule continentsWithHills_se = new(continentsWithPlains, continentsWithHills_ad, terrainTypeDef);
            continentsWithHills_se.SetBounds(1.0f - HILLS_AMOUNT, 1001.0f - HILLS_AMOUNT);
            continentsWithHills_se.EdgeFalloff = 0.25f;

            // 3: [Continents-with-hills subgroup]: Caches the output value from the
            //    select-high-elevations module.
            CacheModule continentsWithHills = new(continentsWithHills_se);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with mountains (5 noise modules)
            //
            // This subgroup applies the scaled-mountainous-terrain group to the
            // continents-with-hills subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Continents-and-mountains module]:  This addition module adds the
            //    scaled-mountainous-terrain group to the base-continent-elevation
            //    subgroup.
            AddModule continentsWithMountains_ad0 = new(baseContinentElev, scaledMountainousTerrain);

            // 2: [Increase-mountain-heights module]:  This curve module applies a curve
            //    to the output value from the continent-definition group.  This
            //    modified output value is used by a subsequent noise module to add
            //    additional height to the mountains based on the current continent
            //    elevation.  The higher the continent elevation, the higher the
            //    mountains.
            CurveModule continentsWithMountains_cu = new(continentDef);
            continentsWithMountains_cu.ControlPoints.Clear();
            continentsWithMountains_cu.ControlPoints.Add(-1.0f, -0.0625f);
            continentsWithMountains_cu.ControlPoints.Add(0.0f, 0.0000f);
            continentsWithMountains_cu.ControlPoints.Add(1.0f - MOUNTAINS_AMOUNT, 0.0625f);
            continentsWithMountains_cu.ControlPoints.Add(1.0f, 0.2500f);

            // 3: [Add-increased-mountain-heights module]: This addition module adds
            //    the increased-mountain-heights module to the continents-and-
            //    mountains module.  The highest continent elevations now have the
            //    highest mountains.
            AddModule continentsWithMountains_ad1 = new(continentsWithMountains_ad0, continentsWithMountains_cu);

            // 4: [Select-high-elevations module]: This selector module ensures that
            //    mountains only appear at higher elevations.  It does this by selecting
            //    the output value from the continent-with-mountains module if the
            //    corresponding output value from the terrain-type-defintion group is
            //    above a certain value.  Otherwise, it selects the output value from
            //    the continents-with-hills subgroup.  Note that the continents-with-
            //    hills subgroup also contains the plains terrain.
            SelectorModule continentsWithMountains_se = new(continentsWithHills, continentsWithMountains_ad1, terrainTypeDef);
            continentsWithMountains_se.SetBounds(1.0f - MOUNTAINS_AMOUNT, 1001.0f - MOUNTAINS_AMOUNT);
            continentsWithMountains_se.EdgeFalloff = 0.25f;

            // 5: [Continents-with-mountains subgroup]: Caches the output value from
            //    the select-high-elevations module.
            CacheModule continentsWithMountains = new(continentsWithMountains_se);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with badlands (5 noise modules)
            //
            // This subgroup applies the scaled-badlands-terrain group to the
            // continents-with-mountains subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Badlands-positions module]: This Perlin-noise module generates some
            //    random noise, which is used by subsequent noise modules to specify the
            //    locations of the badlands.
            PerlinModule continentsWithBadlands_pe = new(noise)
            {
                SeedOffset = CUR_SEED + 140,
                Frequency = 16.5f,
                Persistence = 0.5f,
                Lacunarity = CONTINENT_LACUNARITY,
                OctaveCount = 2
            };

            // 2: [Continents-and-badlands module]:  This addition module adds the
            //    scaled-badlands-terrain group to the base-continent-elevation
            //    subgroup.
            AddModule continentsWithBadlands_ad = new(baseContinentElev, scaledBadlandsTerrain);

            // 3: [Select-badlands-positions module]: This selector module places
            //    badlands at random spots on the continents based on the Perlin noise
            //    generated by the badlands-positions module.  To do this, it selects
            //    the output value from the continents-and-badlands module if the
            //    corresponding output value from the badlands-position module is
            //    greater than a specified value.  Otherwise, this selector module
            //    selects the output value from the continents-with-mountains subgroup.
            //    There is also a wide transition between these two noise modules so
            //    that the badlands can blend into the rest of the terrain on the
            //    continents.
            SelectorModule continentsWithBadlands_se = new(continentsWithMountains, continentsWithBadlands_ad, continentsWithBadlands_pe);
            continentsWithBadlands_se.SetBounds(1.0f - BADLANDS_AMOUNT, 1001.0f - BADLANDS_AMOUNT);
            continentsWithBadlands_se.EdgeFalloff = 0.25f;

            // 4: [Apply-badlands module]: This maximum-value module causes the badlands
            //    to "poke out" from the rest of the terrain.  It does this by ensuring
            //    that only the maximum of the output values from the continents-with-
            //    mountains subgroup and the select-badlands-positions modules
            //    contribute to the output value of this subgroup.  One side effect of
            //    this process is that the badlands will not appear in mountainous
            //    terrain.
            MaxModule continentsWithBadlands_ma = new(continentsWithMountains, continentsWithBadlands_se);

            // 5: [Continents-with-badlands subgroup]: Caches the output value from the
            //    apply-badlands module.
            CacheModule continentsWithBadlands = new(continentsWithBadlands_ma);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with rivers (4 noise modules)
            //
            // This subgroup applies the river-positions group to the continents-with-
            // badlands subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Scaled-rivers module]: This scale/bias module scales the output value
            //    from the river-positions group so that it is measured in planetary
            //    elevation units and is negative; this is required for step 2.
            ScaleBiasModule continentsWithRivers_sb = new(riverPositions)
            {
                Scale = RIVER_DEPTH / 2.0f,
                Bias = -RIVER_DEPTH / 2.0f
            };

            // 2: [Add-rivers-to-continents module]: This addition module adds the
            //    rivers to the continents-with-badlands subgroup.  Because the scaled-
            //    rivers module only outputs a negative value, the scaled-rivers module
            //    carves the rivers out of the terrain.
            AddModule continentsWithRivers_ad = new(continentsWithBadlands, continentsWithRivers_sb);

            // 3: [Blended-rivers-to-continents module]: This selector module outputs
            //    deep rivers near sea level and shallower rivers in higher terrain.  It
            //    does this by selecting the output value from the continents-with-
            //    badlands subgroup if the corresponding output value from the
            //    continents-with-badlands subgroup is far from sea level.  Otherwise,
            //    this selector module selects the output value from the add-rivers-to-
            //    continents module.
            SelectorModule continentsWithRivers_se = new(continentsWithBadlands, continentsWithRivers_ad, continentsWithBadlands);
            continentsWithRivers_se.SetBounds(SEA_LEVEL, CONTINENT_HEIGHT_SCALE + SEA_LEVEL);
            continentsWithRivers_se.EdgeFalloff = CONTINENT_HEIGHT_SCALE - SEA_LEVEL;

            // 4: [Continents-with-rivers subgroup]: Caches the output value from the
            //    blended-rivers-to-continents module.
            CacheModule continentsWithRivers = new(continentsWithRivers_se);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: unscaled final planet (1 noise module)
            //
            // This subgroup simply caches the output value from the continent-with-
            // rivers subgroup to contribute to the final output value.
            //

            // 1: [Unscaled-final-planet subgroup]: Caches the output value from the
            //    continent-with-rivers subgroup.
            CacheModule unscaledFinalPlanet = new(continentsWithRivers);

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: final planet (2 noise modules)
            //
            // This subgroup scales the output value from the unscaled-final-planet
            // subgroup so that it represents an elevation in meters.
            //

            // 1: [Final-planet-in-meters module]: This scale/bias module scales the
            //    output value from the unscaled-final-planet subgroup so that its
            //    output value is measured in meters.
            ScaleBiasModule finalPlanet_sb = new(unscaledFinalPlanet)
            {
                Scale = (MAX_ELEV - MIN_ELEV) / 2.0f,
                Bias = MIN_ELEV + ((MAX_ELEV - MIN_ELEV) / 2.0f)
            };

            // 2: [Final-planet group]: Caches the output value from the final-planet-
            //    in-meters module.  Stick a fork in it, we're done!
            CacheModule finalPlanet = new(finalPlanet_sb);

            ////////////////////////////////////////////////////////////////////////////
            // Check constants
            //
            // This checks the constants entered at the top of the file to make sure
            // they are valid.

            Debug.Assert(SOUTH_COORD < NORTH_COORD);
            Debug.Assert(WEST_COORD < EAST_COORD);
            Debug.Assert(GRID_WIDTH > 0);
            Debug.Assert(GRID_HEIGHT > 0);
            Debug.Assert(PLANET_CIRCUMFERENCE >= 1.0f);
            Debug.Assert(MIN_ELEV < MAX_ELEV);
            Debug.Assert(CONTINENT_FREQUENCY >= 1.0f);
            Debug.Assert(CONTINENT_LACUNARITY >= 1.0f);
            Debug.Assert(CONTINENT_LACUNARITY <= 4.0f);
            Debug.Assert(MOUNTAIN_LACUNARITY >= 1.0f);
            Debug.Assert(MOUNTAIN_LACUNARITY <= 4.0f);
            Debug.Assert(HILLS_LACUNARITY >= 1.0f);
            Debug.Assert(HILLS_LACUNARITY <= 4.0f);
            Debug.Assert(PLAINS_LACUNARITY >= 1.0f);
            Debug.Assert(PLAINS_LACUNARITY <= 4.0f);
            Debug.Assert(BADLANDS_LACUNARITY >= 1.0f);
            Debug.Assert(BADLANDS_LACUNARITY <= 4.0f);
            Debug.Assert(MOUNTAINS_TWIST >= 0.0f);
            Debug.Assert(HILLS_TWIST >= 0.0f);
            Debug.Assert(BADLANDS_TWIST >= 0.0f);
            Debug.Assert(SEA_LEVEL >= -1.0f);
            Debug.Assert(SEA_LEVEL <= 1.0f);
            Debug.Assert(SHELF_LEVEL >= -1.0f);
            Debug.Assert(SHELF_LEVEL <= 1.0f);
            Debug.Assert(SEA_LEVEL > SHELF_LEVEL);
            Debug.Assert(MOUNTAINS_AMOUNT >= 0.0f);
            Debug.Assert(MOUNTAINS_AMOUNT <= 1.0f);
            Debug.Assert(HILLS_AMOUNT >= 0.0f);
            Debug.Assert(HILLS_AMOUNT <= 1.0f);
            Debug.Assert(BADLANDS_AMOUNT >= 0.0f);
            Debug.Assert(BADLANDS_AMOUNT <= 1.0f);
            Debug.Assert(MOUNTAINS_AMOUNT < HILLS_AMOUNT);
            Debug.Assert(MOUNTAIN_GLACIATION >= 1.0f);
            Debug.Assert(RIVER_DEPTH >= 0.0f);

            ////////////////////////////////////////////////////////////////////////////
            // Create the elevation grid and resulting images

            File.WriteAllText(string.Concat(outputDir, "terrain.hlsl"), finalPlanet.GetFullHlsl());

            // First, create a spherical-noise-map builder.
            // Pass in the boundaries of the elevation grid to extract.
            SphereBuilder planet = new(finalPlanet, noise.Seed, SOUTH_COORD, NORTH_COORD, WEST_COORD, EAST_COORD);

            // Build the elevation grid with the output values from the final-planet
            // group.
            Console.WriteLine("elevGrid");
            ValueMap elevGrid = MapGenerator.GenerateValueMap(planet, GRID_WIDTH, GRID_HEIGHT);

            // Calculate the spatial resolution of the elevation grid, in meters.
            // Assume that the spatial resolution is the same in both the x and y
            // directions.  This is needed by the Terragen file writer.
            float degExtent = EAST_COORD - WEST_COORD;
            float gridExtent = GRID_WIDTH;
            float metersPerDegree = PLANET_CIRCUMFERENCE / 360.0f;
            float resInMeters = degExtent / gridExtent * metersPerDegree;

            // Write the elevation grid as a raw file (*.raw)
            using (FileStream rawFile = File.OpenWrite(string.Concat(outputDir, "terrain.raw")))
            using (var writer = new BinaryWriter(rawFile))
            {
                for (int i = 0; i < elevGrid.Data.Length; i++)
                {
                    short elev = (short)Math.Floor(elevGrid.Data[i]);
                    writer.Write(elev);
                }
            }

            // Calculate the sea level, in meters.
            float seaLevelInMeters = ((SEA_LEVEL + 1.0f) / 2.0f * (MAX_ELEV - MIN_ELEV)) + MIN_ELEV;

            // Now generate an image that is colored by elevation and has an artificial
            // light-source.
            Console.WriteLine("terrain");
            ImageRenderer imageRenderer = new(planet, false, false);
            imageRenderer.ClearGradient();
            imageRenderer.AddGradientPoint(-16384.0f + seaLevelInMeters, Color.FromArgb(255, 0, 0, 0));
            imageRenderer.AddGradientPoint(-256f + seaLevelInMeters, Color.FromArgb(255, 6, 58, 127));
            imageRenderer.AddGradientPoint(-1.0f + seaLevelInMeters, Color.FromArgb(255, 14, 112, 192));
            imageRenderer.AddGradientPoint(0.0f + seaLevelInMeters, Color.FromArgb(255, 70, 120, 60));
            imageRenderer.AddGradientPoint(1024.0f + seaLevelInMeters, Color.FromArgb(255, 110, 140, 75));
            imageRenderer.AddGradientPoint(2048.0f + seaLevelInMeters, Color.FromArgb(255, 160, 140, 111));
            imageRenderer.AddGradientPoint(3072.0f + seaLevelInMeters, Color.FromArgb(255, 184, 163, 141));
            imageRenderer.AddGradientPoint(4096.0f + seaLevelInMeters, Color.FromArgb(255, 255, 255, 255));
            imageRenderer.AddGradientPoint(6144.0f + seaLevelInMeters, Color.FromArgb(255, 128, 255, 255));
            imageRenderer.AddGradientPoint(16384.0f + seaLevelInMeters, Color.FromArgb(255, 0, 0, 255));
            imageRenderer.IsLightEnabled = true;
            imageRenderer.LightContrast = 1.0f / resInMeters;
            imageRenderer.LightIntensity = 2.0f;
            imageRenderer.LightElevation = 45.0f;
            imageRenderer.LightAzimuth = 135.0f;

            // Write the image as a Windows bitmap file (*.bmp).
            MapGenerator
                .GenerateColorMapOnCpu(imageRenderer, GRID_WIDTH, GRID_HEIGHT)
                .SaveBitmap(string.Concat(outputDir, "terrain.png"));

            // Flatten the seas that are deeper than 15 meters or so.  We do not flatten
            // all the seas so that we can color the shallow areas with a different
            // color than the deeper seas.
            Console.WriteLine("deep sea level");
            const float DEEP_SEA_LEVEL = -256.0f;

            Parallel.ForEach(Partitioner.Create(0, elevGrid.Data.Length), range =>
            {
                for (int index = range.Item1; index < range.Item2; index++)
                {
                    if (elevGrid.Data[index] < SEA_LEVEL + DEEP_SEA_LEVEL)
                    {
                        elevGrid.Data[index] = SEA_LEVEL + DEEP_SEA_LEVEL;
                    }
                }
            });

            // Now generate the surface map.  This is an unshaded map that is colored by
            // elevation.  Using OpenGL or another 3D API, a surface map can be used in
            // conjunction with a normal map to light the map in any direction in real
            // time.
            Console.WriteLine("terrainsurface");
            ImageRenderer surfaceRenderer = new(planet, false, false);
            surfaceRenderer.ClearGradient();
            surfaceRenderer.AddGradientPoint(-16384.0f + seaLevelInMeters, Color.FromArgb(255, 3, 29, 63));
            surfaceRenderer.AddGradientPoint(DEEP_SEA_LEVEL + seaLevelInMeters, Color.FromArgb(255, 3, 29, 63));
            surfaceRenderer.AddGradientPoint(-1.0f + seaLevelInMeters, Color.FromArgb(255, 7, 106, 127));
            surfaceRenderer.AddGradientPoint(0.0f + seaLevelInMeters, Color.FromArgb(255, 62, 86, 30));
            surfaceRenderer.AddGradientPoint(1024.0f + seaLevelInMeters, Color.FromArgb(255, 84, 96, 50));
            surfaceRenderer.AddGradientPoint(2048.0f + seaLevelInMeters, Color.FromArgb(255, 130, 127, 97));
            surfaceRenderer.AddGradientPoint(3072.0f + seaLevelInMeters, Color.FromArgb(255, 184, 163, 141));
            surfaceRenderer.AddGradientPoint(4096.0f + seaLevelInMeters, Color.FromArgb(255, 255, 255, 255));
            surfaceRenderer.AddGradientPoint(6144.0f + seaLevelInMeters, Color.FromArgb(255, 128, 255, 255));
            surfaceRenderer.AddGradientPoint(16384.0f + seaLevelInMeters, Color.FromArgb(255, 0, 0, 255));
            surfaceRenderer.IsLightEnabled = false;

            // Write the image as a Windows bitmap file (*.bmp).
            MapGenerator
                .GenerateColorMapOnCpu(surfaceRenderer, GRID_WIDTH, GRID_HEIGHT)
                .SaveBitmap(string.Concat(outputDir, "terrainsurface.png"));

            // Save to libnoise file
            LibNoiseShaderFileWriteContext
                .BuildLibNoiseShaderFile(surfaceRenderer, noise)
                .Write(string.Concat(outputDir, "terrain.libnoise"));

            // Save to hlsl file
            File.WriteAllText(string.Concat(outputDir, "terrain.hlsl"), surfaceRenderer.GetFullHlsl());

            // Now generate the specularity map.  This defines the "shininess" of the
            // elevation grid.  Water areas are the shiniest.
            Console.WriteLine("terrainspec");
            ImageRenderer specularityRenderer = new(planet, false, false);
            specularityRenderer.ClearGradient();
            specularityRenderer.AddGradientPoint(MIN_ELEV, Color.FromArgb(255, 255, 255, 255));
            specularityRenderer.AddGradientPoint(seaLevelInMeters, Color.FromArgb(255, 255, 255, 255));
            specularityRenderer.AddGradientPoint(seaLevelInMeters + 1.0f, Color.FromArgb(255, 0, 0, 0));
            specularityRenderer.AddGradientPoint(MAX_ELEV, Color.FromArgb(255, 128, 128, 128));
            specularityRenderer.IsLightEnabled = false;

            // Write the specularity map as a Windows bitmap file (*.bmp).
            MapGenerator
                .GenerateColorMapOnCpu(specularityRenderer, GRID_WIDTH, GRID_HEIGHT)
                .SaveBitmap(string.Concat(outputDir, "terrainspec.png"));

            // Finally, render the normal map.  Using OpenGL or another 3D API, a
            // surface map can be used in conjunction with a normal map to light the map
            // in any direction in real time.
            Console.WriteLine("terrainnormal");
            NormalRenderer normalMapRenderer = new(planet, 1.0f / resInMeters, false);

            // Write the normal map as a Windows bitmap file (*.bmp).
            MapGenerator
                .GenerateColorMapOnCpu(normalMapRenderer, GRID_WIDTH, GRID_HEIGHT)
                .SaveBitmap(string.Concat(outputDir, "terrainnormal.png"));
        }
    }
}
